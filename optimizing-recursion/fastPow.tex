% Setting up the document with necessary packages
\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{geometry}
\geometry{a4paper, margin=1in}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{xcolor}

% Defining code listing style
\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny,
    keywordstyle=\color{blue},
    commentstyle=\color{gray}
}

% Setting font package last
\usepackage{noto}

\begin{document}

    \title{Fast Exponentiation: The Square-and-Multiply Algorithm}
    \author{}
    \date{}
    \maketitle

    \section{Introduction}
% Explaining the purpose and context
    Exponentiation, or raising a number to a power, is a common operation in mathematics and computer science. For example, computing \(3^{13}\) means multiplying 3 by itself 13 times. However, for large exponents, this naive approach is slow and inefficient. The \emph{square-and-multiply} algorithm (also known as fast exponentiation) provides a much faster way to compute large powers by using the binary representation of the exponent. This document explains how the algorithm works, how to compute the binary representation of an exponent, why the algorithm is efficient, and walks through an example for students.

    \section{Converting the Exponent to Binary}
% Explaining how to convert the exponent to binary
    The square-and-multiply algorithm relies on the binary representation of the exponent. Any positive integer can be expressed as a sum of powers of 2 by converting it to binary. For example, let’s convert the exponent 13 to binary by repeatedly dividing by 2 and recording the remainders:

    \begin{enumerate}
        \item Divide \(13 \div 2 = 6\) remainder \(1\) (since \(13 = 2 \cdot 6 + 1\)).
        \item Divide \(6 \div 2 = 3\) remainder \(0\) (since \(6 = 2 \cdot 3 + 0\)).
        \item Divide \(3 \div 2 = 1\) remainder \(1\) (since \(3 = 2 \cdot 1 + 1\)).
        \item Divide \(1 \div 2 = 0\) remainder \(1\) (since \(1 = 2 \cdot 0 + 1\)).
        \item Stop when the quotient is 0.
    \end{enumerate}

    The binary representation is obtained by reading the remainders from bottom to top: \(1101\). Thus:
    \[
        13 = 1 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 8 + 4 + 0 + 1.
    \]
    This means \(3^{13}\) can be written as:
    \[
        3^{13} = 3^{8 + 4 + 1} = 3^8 \cdot 3^4 \cdot 3^1.
    \]
    The algorithm processes these bits (1, 0, 1, 1) from right to left to compute the result efficiently.

    \section{The Idea Behind the Algorithm}
% Introducing the binary representation concept
    The key idea is to use the binary form of the exponent to minimize multiplications. Instead of performing 12 multiplications for \(3^{13}\), we compute only the powers corresponding to the 1’s in the binary representation (e.g., \(3^8\), \(3^4\), \(3^1\)). We achieve this by:
    \begin{itemize}
        \item \textbf{Squaring} the base at each step to double its power (e.g., from \(3^2\) to \(3^4\), then to \(3^8\)).
        \item \textbf{Multiplying} the result by the current base only when the corresponding binary bit is 1.
    \end{itemize}
    This reduces the number of operations to approximately \(\log_2 n\), where \(n\) is the exponent.

    \section{The Algorithm}
% Describing the algorithm step-by-step
    The square-and-multiply algorithm can be described as follows:
    \begin{enumerate}
        \item Initialize a \texttt{result} to 1, the \texttt{base} to the given number, and the \texttt{exponent} to the given power.
        \item While the \texttt{exponent} is greater than 0:
        \begin{enumerate}[label=(\alph*)]
            \item Check if the \texttt{exponent} is odd (equivalent to the current binary bit being 1).
            \item If odd, multiply \texttt{result} by the current \texttt{base}.
            \item Square the \texttt{base} (i.e., \texttt{base = base * base}).
            \item Divide the \texttt{exponent} by 2 (integer division, moving to the next binary bit).
        \end{enumerate}
        \item Return the \texttt{result}.
    \end{enumerate}

    Here is the algorithm in pseudocode:
    \begin{lstlisting}[language=Java]
function pow(base, exponent):
    if exponent < 0:
        throw error "Exponent must be non-negative"
    if exponent = 0:
        return 1
    result = 1
    while exponent > 0:
        if exponent % 2 == 1:
            result = result * base
        base = base * base
        exponent = exponent / 2
    return result
    \end{lstlisting}

    \section{Why Square at Every Step?}
% Explaining the squaring step
    Squaring the base at every step is crucial because it doubles the exponent of the base, preparing it for the next binary bit. For example:
    \begin{itemize}
        \item Initially, \texttt{base} represents \(base^1\).
        \item After the first square, \texttt{base} becomes \(base^2\).
        \item After the second square, \texttt{base} becomes \(base^4\), and so on.
    \end{itemize}
    This ensures that when we encounter a binary bit of 1, the \texttt{base} corresponds to the correct power of 2 (e.g., \(base^4\) for the bit representing \(2^2\)). If we only squared the base when the bit is 1, we would not have the correct power for subsequent bits, leading to an incorrect result.

    \section{Example: Computing \(3^{13}\)}
% Walking through the example with binary conversion
    Let’s start by converting the exponent 13 to binary using successive division by 2, as shown below:

    \begin{align*}
        13 &= (?)_2 \\
        \frac{13}{2} &= 6 + 1 \\
        \frac{6}{2} &= 3 + 0 \\
        \frac{3}{2} &= 1 + 1 \\
        \frac{1}{2} &= 0 + 1 \\
    \end{align*}
    Reading the remainders from bottom to top, we get \(B = 1101_2\), where \(b_3 = 1\), \(b_2 = 1\), \(b_1 = 0\), \(b_0 = 1\). Thus:
    \[
        N = b_3 \cdot 2^3 + b_2 \cdot 2^2 + b_1 \cdot 2^1 + b_0 \cdot 2^0,
    \]
    \[
        N = 1 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 8 + 4 + 0 + 1 = 13.
    \]
    So, \(3^{13} = 3^{8 + 4 + 1} = 3^8 \cdot 3^4 \cdot 3^1\). Now, let’s compute it using the algorithm, processing the bits 1, 0, 1, 1 from right to left.

    \begin{enumerate}
        \item \textbf{Initialization}: Set \texttt{result = 1}, \texttt{base = 3}, \texttt{exponent = 13}.
        \item \textbf{Step 1 (bit 1, \(2^0\))}:
        \begin{itemize}
            \item \texttt{exponent = 13}, which is odd (\texttt{13 \% 2 = 1}).
            \item Multiply: \texttt{result = 1 * 3 = 3} (include \(3^1\)).
            \item Square: \texttt{base = 3 * 3 = 9} (now \texttt{base = \(3^2\)}).
            \item Divide: \texttt{exponent = 13 / 2 = 6}.
        \end{itemize}
        \item \textbf{Step 2 (bit 0, \(2^1\))}:
        \begin{itemize}
            \item \texttt{exponent = 6}, which is even (\texttt{6 \% 2 = 0}).
            \item No multiplication (bit is 0).
            \item Square: \texttt{base = 9 * 9 = 81} (now \texttt{base = \(3^4\)}).
            \item Divide: \texttt{exponent = 6 / 2 = 3}.
        \end{itemize}
        \item \textbf{Step 3 (bit 1, \(2^2\))}:
        \begin{itemize}
            \item \texttt{exponent = 3}, which is odd (\texttt{3 \% 2 = 1}).
            \item Multiply: \texttt{result = 3 * 81 = 243} (include \(3^4\)).
            \item Square: \texttt{base = 81 * 81 = 6561} (now \texttt{base = \(3^8\)}).
            \item Divide: \texttt{exponent = 3 / 2 = 1}.
        \end{itemize}
        \item \textbf{Step 4 (bit 1, \(2^3\))}:
        \begin{itemize}
            \item \texttt{exponent = 1}, which is odd (\texttt{1 \% 2 = 1}).
            \item Multiply: \texttt{result = 243 * 6561 = 1594323} (include \(3^8\)).
            \item Square: \texttt{base = 6561 * 6561 = 43046721} (not used).
            \item Divide: \texttt{exponent = 1 / 2 = 0}.
        \end{itemize}
        \item \textbf{End}: \texttt{exponent = 0}, return \texttt{result = 1594323}.
    \end{enumerate}

    The final result is \(3^{13} = 1594323\). Let’s verify:
    \[
        3^1 = 3, \quad 3^4 = 81, \quad 3^8 = 6561.
    \]
    \[
        3^1 \cdot 3^4 \cdot 3^8 = 3 \cdot 81 \cdot 6561 = 243 \cdot 6561 = 1594323.
    \]
    The result is correct.

    \section{Efficiency}
% Explaining why the algorithm is efficient
    The naive approach to compute \(3^{13}\) requires 12 multiplications. The square-and-multiply algorithm uses:
    \begin{itemize}
        \item 4 squaring operations (one for each bit of 13, which is 1101).
        \item 3 multiplications (for the three 1’s in the binary representation).
    \end{itemize}
    This totals 7 operations, which is much fewer than 12. For larger exponents, the savings are even greater, as the number of operations is proportional to \(\log_2 n\), where \(n\) is the exponent.

    \section{Conclusion}
% Summarizing the key points
    The square-and-multiply algorithm is a powerful tool for computing large powers efficiently. By leveraging the binary representation of the exponent, obtained through successive division by 2, it reduces the number of multiplications needed. Squaring the base at every step ensures that the correct powers are available when needed, and multiplying only for 1’s in the binary form minimizes operations. This method is widely used in computer science, especially in cryptography, where large exponents are common.

\end{document}