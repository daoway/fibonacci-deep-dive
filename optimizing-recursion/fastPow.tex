% Setting up the document with necessary packages
\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{geometry}
\geometry{a4paper, margin=1in}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{array}

% Defining code listing style for Java
\lstset{
	language=Java,
	basicstyle=\ttfamily\small,
	breaklines=true,
	frame=single,
	numbers=left,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue}\bfseries,
	commentstyle=\color{green!60!black}\itshape,
	stringstyle=\color{red},
	showstringspaces=false,
	tabsize=4
}

% Setting font package last
\usepackage{noto}

\begin{document}
	
	\title{Fast Exponentiation: Introduction to Matrix Exponentiation}
	\author{}
	\date{}
	\maketitle
	
	\tableofcontents
	
	\section{Introduction}
	
	Exponentiation---raising a number to a power---is a fundamental operation in mathematics and computer science. Computing $b^n$ naively requires $n-1$ multiplications, which becomes prohibitively expensive for large exponents. The \emph{square-and-multiply algorithm} (also known as \emph{binary exponentiation} or \emph{exponentiation by squaring}) provides an elegant solution by leveraging the binary representation of the exponent.
	
	\section{The Binary Representation}
	
	The key insight is that any positive integer can be expressed as a sum of powers of 2. Consider computing $3^{13}$. We first convert the exponent 13 to binary using successive division by 2:
	
	\begin{align*}
		13 \div 2 &= 6 \text{ remainder } 1 \\
		6 \div 2 &= 3 \text{ remainder } 0 \\
		3 \div 2 &= 1 \text{ remainder } 1 \\
		1 \div 2 &= 0 \text{ remainder } 1
	\end{align*}
	
	Reading the remainders from bottom to top yields $13 = 1101_2$. In expanded form:
	\[
	13 = b_3 \cdot 2^3 + b_2 \cdot 2^2 + b_1 \cdot 2^1 + b_0 \cdot 2^0
	\]
	where $b_3 = 1$, $b_2 = 1$, $b_1 = 0$, $b_0 = 1$. Thus:
	\[
	13 = 1 \cdot 8 + 1 \cdot 4 + 0 \cdot 2 + 1 \cdot 1 = 8 + 4 + 1
	\]
	
	This decomposition allows us to rewrite the exponentiation:
	\[
	3^{13} = 3^{8+4+1} = 3^8 \cdot 3^4 \cdot 3^1
	\]
	
	Instead of computing 12 multiplications ($3 \times 3 \times \cdots \times 3$), we need only compute $3^8$, $3^4$, and $3^1$, then multiply these results together.
	
	\section{The Algorithm}
	
	\subsection{Core Idea}
	
	The algorithm processes the binary representation of the exponent from right to left (least significant bit to most significant bit), maintaining two values:
	\begin{itemize}[itemsep=2pt]
		\item \textbf{result}: Accumulates the final answer by multiplying in powers of the base corresponding to 1-bits
		\item \textbf{base}: Doubles its exponent at each step through repeated squaring
	\end{itemize}
	
	At each iteration:
	\begin{enumerate}[itemsep=2pt]
		\item \textbf{Check the bit}: If the current bit is 1 (exponent is odd), multiply \texttt{result} by the current \texttt{base}
		\item \textbf{Square the base}: Update \texttt{base} to \texttt{base}$^2$ to prepare for the next bit
		\item \textbf{Shift to next bit}: Divide the exponent by 2 (integer division)
	\end{enumerate}
	
	\subsection{Why Square at Every Step?}
	
	Squaring the base at each iteration is essential because it ensures we have the correct power available for each binary bit position. The progression is:
	\begin{align*}
		\text{Initially:} \quad & \texttt{base} = b^1 \\
		\text{After 1st square:} \quad & \texttt{base} = b^2 \\
		\text{After 2nd square:} \quad & \texttt{base} = b^4 \\
		\text{After 3rd square:} \quad & \texttt{base} = b^8 \\
		& \vdots
	\end{align*}
	
	This sequence $b^1, b^2, b^4, b^8, \ldots, b^{2^k}$ corresponds exactly to the powers needed for each bit position in the binary representation. If we only squared when encountering a 1-bit, subsequent powers would be incorrect.
	
	\subsection{Java Implementation}
	
	Here is the complete Java implementation of the fast exponentiation algorithm:
	
	\begin{lstlisting}
		public class FastExponentiation {
			
			/**
			* Computes base^exponent using the square-and-multiply algorithm
			* Time Complexity: O(log n) where n is the exponent
			* 
			* @param base the base number
			* @param exponent the exponent (must be non-negative)
			* @return base raised to the power of exponent
			* @throws IllegalArgumentException if exponent is negative
			*/
			public static long power(long base, int exponent) {
				// Handle negative exponents
				if (exponent < 0) {
					throw new IllegalArgumentException(
					"Exponent must be non-negative"
					);
				}
				
				// Base case: any number to the power 0 is 1
				if (exponent == 0) {
					return 1;
				}
				
				long result = 1;
				long currentBase = base;
				int currentExponent = exponent;
				
				while (currentExponent > 0) {
					// Check if the current exponent is odd
					if (currentExponent % 2 == 1) {
						result *= currentBase;
					}
					
					// Square the base for the next bit position
					currentBase *= currentBase;
					
					// Move to the next bit (integer division by 2)
					currentExponent /= 2;
				}
				
				return result;
			}
			
			/**
			* Modular exponentiation: computes (base^exponent) % modulus
			* Prevents overflow by taking modulus at each step
			* Essential for cryptographic applications
			*/
			public static long modularPower(long base, int exponent, long modulus) {
				if (exponent < 0) {
					throw new IllegalArgumentException(
					"Exponent must be non-negative"
					);
				}
				
				if (modulus <= 0) {
					throw new IllegalArgumentException(
					"Modulus must be positive"
					);
				}
				
				long result = 1;
				base %= modulus; // Reduce base first
				
				while (exponent > 0) {
					if (exponent % 2 == 1) {
						result = (result * base) % modulus;
					}
					
					base = (base * base) % modulus;
					exponent /= 2;
				}
				
				return result;
			}
			
			// Test the implementation
			public static void main(String[] args) {
				System.out.println("Computing 3^13:");
				System.out.println("Result: " + power(3, 13));
				System.out.println("Expected: 1594323");
				System.out.println();
				
				System.out.println("Computing 2^10:");
				System.out.println("Result: " + power(2, 10));
				System.out.println("Expected: 1024");
				System.out.println();
				
				System.out.println("Modular exponentiation: (7^256) % 13:");
				System.out.println("Result: " + modularPower(7, 256, 13));
			}
		}
	\end{lstlisting}
	
	\section{Worked Example: Computing $3^{13}$}
	
	Let us trace the algorithm's execution for $3^{13}$, processing the binary representation $1101_2$ from right to left:
	
	\begin{table}[h]
		\centering
		\begin{tabular}{ccccccl}
			\toprule
			\textbf{Step} & \textbf{Exponent} & \textbf{Bit} & \textbf{Bit Value} & \textbf{Result} & \textbf{Base} & \textbf{Operation} \\
			\midrule
			Initial & 13 & -- & -- & 1 & 3 & Initialize \\
			1 & 13 & $2^0$ & 1 & $1 \times 3 = 3$ & $3^2 = 9$ & Multiply, square \\
			2 & 6 & $2^1$ & 0 & 3 & $9^2 = 81$ & Square only \\
			3 & 3 & $2^2$ & 1 & $3 \times 81 = 243$ & $81^2 = 6561$ & Multiply, square \\
			4 & 1 & $2^3$ & 1 & $243 \times 6561 = 1594323$ & -- & Multiply, done \\
			\bottomrule
		\end{tabular}
		\caption{Step-by-step execution of the square-and-multiply algorithm for $3^{13}$}
	\end{table}
	
	\subsection{Detailed Trace}
	
	\begin{enumerate}[leftmargin=*]
		\item \textbf{Initialization}: 
		\[\texttt{result} = 1, \quad \texttt{base} = 3, \quad \texttt{exponent} = 13\]
		
		\item \textbf{Step 1} (bit $b_0 = 1$ for $2^0$):
		\begin{itemize}
			\item Check: $13 \bmod 2 = 1$ (odd) $\Rightarrow$ bit is 1
			\item Multiply: $\texttt{result} = 1 \times 3 = 3$
			\item Square: $\texttt{base} = 3 \times 3 = 9$
			\item Shift: $\texttt{exponent} = 13 / 2 = 6$
		\end{itemize}
		
		\item \textbf{Step 2} (bit $b_1 = 0$ for $2^1$):
		\begin{itemize}
			\item Check: $6 \bmod 2 = 0$ (even) $\Rightarrow$ bit is 0
			\item No multiplication
			\item Square: $\texttt{base} = 9 \times 9 = 81$
			\item Shift: $\texttt{exponent} = 6 / 2 = 3$
		\end{itemize}
		
		\item \textbf{Step 3} (bit $b_2 = 1$ for $2^2$):
		\begin{itemize}
			\item Check: $3 \bmod 2 = 1$ (odd) $\Rightarrow$ bit is 1
			\item Multiply: $\texttt{result} = 3 \times 81 = 243$
			\item Square: $\texttt{base} = 81 \times 81 = 6561$
			\item Shift: $\texttt{exponent} = 3 / 2 = 1$
		\end{itemize}
		
		\item \textbf{Step 4} (bit $b_3 = 1$ for $2^3$):
		\begin{itemize}
			\item Check: $1 \bmod 2 = 1$ (odd) $\Rightarrow$ bit is 1
			\item Multiply: $\texttt{result} = 243 \times 6561 = 1594323$
			\item Square: $\texttt{base} = 6561 \times 6561$ (not used)
			\item Shift: $\texttt{exponent} = 1 / 2 = 0$
		\end{itemize}
		
		\item \textbf{Termination}: $\texttt{exponent} = 0$, return $\texttt{result} = 1594323$
	\end{enumerate}
	
	\subsection{Verification}
	
	\[
	3^{13} = 3^1 \cdot 3^4 \cdot 3^8 = 3 \times 81 \times 6561 = 1594323 \quad \checkmark
	\]
	
	\section{Complexity Analysis}
	
	\begin{itemize}
		\item \textbf{Naive approach}: $O(n)$ multiplications (requires $n-1$ multiplications)
		\item \textbf{Square-and-multiply}: $O(\log n)$ multiplications
	\end{itemize}
	
	For $3^{13}$:
	\begin{itemize}
		\item Naive: 12 multiplications
		\item Square-and-multiply: 7 operations (4 squarings + 3 multiplications)
	\end{itemize}
	
	This efficiency gain becomes crucial when working with large exponents or when the "multiplication" operation is expensive, as it is with matrices.
	
	\section{Extension to Matrix Exponentiation}
	
	The beauty of the square-and-multiply algorithm is that it works for \emph{any} algebraic structure with an associative multiplication operation. Matrices satisfy this property, so the algorithm extends naturally to matrix exponentiation.
	
	\subsection{Mathematical Foundation}
	
	\subsubsection{Associativity of Matrix Multiplication}
	
	The key property that allows this algorithm to work is \textbf{associativity}. For matrices $A$, $B$, and $C$:
	\[
	(A \cdot B) \cdot C = A \cdot (B \cdot C)
	\]
	
	This means we can compute products in any order without changing the result. This is crucial because our algorithm rearranges the order of multiplications.
	
	\subsubsection{Identity Element}
	
	Just as $1$ is the multiplicative identity for numbers ($a \cdot 1 = a$), the identity matrix $I$ serves this role for matrices:
	\[
	A \cdot I = I \cdot A = A
	\]
	
	For a $2 \times 2$ matrix:
	\[
	I = \begin{pmatrix} 1 & 0 \\ 0 & 1 \end{pmatrix}
	\]
	
	This allows us to initialize our result to $I$, just as we initialized the scalar result to $1$.
	
	\subsection{Why the Algorithm Works for Matrices}
	
	Let's prove that $A^{13}$ can be computed using the same binary decomposition. We have:
	\[
	13 = 8 + 4 + 1 = 2^3 + 2^2 + 2^0
	\]
	
	Therefore:
	\[
	A^{13} = A^{8+4+1} = A^8 \cdot A^4 \cdot A^1
	\]
	
	This equality holds because of the \textbf{laws of exponents}, which work for matrices:
	\[
	A^{m+n} = A^m \cdot A^n \quad \text{(for any } m, n \geq 0\text{)}
	\]
	
	\textbf{Proof of the exponent law for matrices:}
	\begin{align*}
		A^{m+n} &= \underbrace{A \cdot A \cdot \ldots \cdot A}_{m+n \text{ times}} \\
		&= \underbrace{A \cdot A \cdot \ldots \cdot A}_{m \text{ times}} \cdot \underbrace{A \cdot A \cdot \ldots \cdot A}_{n \text{ times}} \\
		&= A^m \cdot A^n
	\end{align*}
	
	This proof works because matrix multiplication is associative, so we can group the multiplications however we want.
	
	\subsection{Detailed Mathematical Walkthrough}
	
	Let's trace how the algorithm computes $A^{13}$ step by step, showing the mathematical equivalence at each stage.
	
	\textbf{Initialization:}
	\[
	\text{result} = I, \quad \text{base} = A, \quad \text{exponent} = 13
	\]
	
	\textbf{Step 1} (bit $b_0 = 1$, representing $2^0 = 1$):
	\begin{itemize}
		\item Since $13 \bmod 2 = 1$, we multiply:
		\[
		\text{result} = I \cdot A = A = A^1
		\]
		\item We square the base:
		\[
		\text{base} = A \cdot A = A^2
		\]
		\item Exponent becomes $\lfloor 13/2 \rfloor = 6$
	\end{itemize}
	
	\textbf{Step 2} (bit $b_1 = 0$, representing $2^1 = 2$):
	\begin{itemize}
		\item Since $6 \bmod 2 = 0$, we don't multiply (bit is 0)
		\item Result stays: $\text{result} = A^1$
		\item We square the base:
		\[
		\text{base} = A^2 \cdot A^2 = A^4
		\]
		\item Exponent becomes $\lfloor 6/2 \rfloor = 3$
	\end{itemize}
	
	\textbf{Step 3} (bit $b_2 = 1$, representing $2^2 = 4$):
	\begin{itemize}
		\item Since $3 \bmod 2 = 1$, we multiply:
		\[
		\text{result} = A^1 \cdot A^4 = A^{1+4} = A^5
		\]
		\item We square the base:
		\[
		\text{base} = A^4 \cdot A^4 = A^8
		\]
		\item Exponent becomes $\lfloor 3/2 \rfloor = 1$
	\end{itemize}
	
	\textbf{Step 4} (bit $b_3 = 1$, representing $2^3 = 8$):
	\begin{itemize}
		\item Since $1 \bmod 2 = 1$, we multiply:
		\[
		\text{result} = A^5 \cdot A^8 = A^{5+8} = A^{13}
		\]
		\item Exponent becomes $\lfloor 1/2 \rfloor = 0$
	\end{itemize}
	
	\textbf{Result:} We have successfully computed $A^{13}$ using only 7 matrix multiplications instead of 12!
	
	\subsection{General Mathematical Proof}
	
	\textbf{Theorem:} The square-and-multiply algorithm correctly computes $A^n$ for any matrix $A$ and non-negative integer $n$.
	
	\textbf{Proof by Induction on the binary representation:}
	
	Let $n = \sum_{i=0}^{k} b_i \cdot 2^i$ where $b_i \in \{0, 1\}$ is the binary representation.
	
	We want to show that the algorithm computes:
	\[
	A^n = A^{\sum_{i=0}^{k} b_i \cdot 2^i} = \prod_{i=0}^{k} (A^{2^i})^{b_i}
	\]
	
	where $(A^{2^i})^{b_i} = A^{2^i}$ if $b_i = 1$, and $(A^{2^i})^{b_i} = I$ if $b_i = 0$.
	
	\textbf{Invariant:} After processing $j$ bits, we have:
	\begin{align*}
		\text{result} &= \prod_{i=0}^{j-1} (A^{2^i})^{b_i} \\
		\text{base} &= A^{2^j}
	\end{align*}
	
	\textbf{Base case} ($j = 0$): 
	\[
	\text{result} = I = \text{empty product}, \quad \text{base} = A = A^{2^0}
	\]
	
	\textbf{Inductive step:} Assume the invariant holds after $j$ iterations. In iteration $j+1$:
	\begin{itemize}
		\item If $b_j = 1$: 
		\[
		\text{result}_{\text{new}} = \text{result}_{\text{old}} \cdot \text{base} = \prod_{i=0}^{j-1} (A^{2^i})^{b_i} \cdot A^{2^j} = \prod_{i=0}^{j} (A^{2^i})^{b_i}
		\]
		\item If $b_j = 0$:
		\[
		\text{result}_{\text{new}} = \text{result}_{\text{old}} = \prod_{i=0}^{j-1} (A^{2^i})^{b_i} = \prod_{i=0}^{j} (A^{2^i})^{b_i}
		\]
		(since $(A^{2^j})^0 = I$ contributes nothing)
		\item Base is squared:
		\[
		\text{base}_{\text{new}} = \text{base}_{\text{old}}^2 = (A^{2^j})^2 = A^{2 \cdot 2^j} = A^{2^{j+1}}
		\]
	\end{itemize}
	
	After all $k+1$ iterations:
	\[
	\text{result} = \prod_{i=0}^{k} (A^{2^i})^{b_i} = A^{\sum_{i=0}^{k} b_i \cdot 2^i} = A^n \quad \square
	\]
	
	\subsection{Java Implementation for Matrices}
	
	\begin{lstlisting}
		public class MatrixExponentiation {
			
			/**
			* Computes A^n using the square-and-multiply algorithm
			* Time Complexity: O(d^3 * log n) where d is matrix dimension
			*/
			public static int[][] matrixPower(int[][] A, int n) {
				if (n < 0) {
					throw new IllegalArgumentException(
					"Exponent must be non-negative"
					);
				}
				
				int size = A.length;
				int[][] result = identity(size); // Start with I
				int[][] base = copyMatrix(A);    // Start with A
				
				while (n > 0) {
					if (n % 2 == 1) {
						// Include current power of A
						result = multiply(result, base);
					}
					// Square the base for next bit position
					base = multiply(base, base);
					n /= 2;
				}
				
				return result;
			}
			
			/**
			* Creates an identity matrix of given size
			*/
			private static int[][] identity(int size) {
				int[][] I = new int[size][size];
				for (int i = 0; i < size; i++) {
					I[i][i] = 1;
				}
				return I;
			}
			
			/**
			* Multiplies two matrices
			*/
			private static int[][] multiply(int[][] A, int[][] B) {
				int n = A.length;
				int[][] C = new int[n][n];
				
				for (int i = 0; i < n; i++) {
					for (int j = 0; j < n; j++) {
						for (int k = 0; k < n; k++) {
							C[i][j] += A[i][k] * B[k][j];
						}
					}
				}
				
				return C;
			}
			
			/**
			* Creates a copy of a matrix
			*/
			private static int[][] copyMatrix(int[][] A) {
				int n = A.length;
				int[][] copy = new int[n][n];
				for (int i = 0; i < n; i++) {
					for (int j = 0; j < n; j++) {
						copy[i][j] = A[i][j];
					}
				}
				return copy;
			}
		}
	\end{lstlisting}
	
\end{document}